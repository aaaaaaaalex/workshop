# Create Deployment Which Maintains Long-Lived Connections

## Apply a DaemonSet YAML

Create a deployment which will accept new connections
and keep them open, until we manually close them, or
until the connection idles long enough to time out (20s).

```sh
kubectl apply -f -<<EOF
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: http-longlived-server
  labels:
    app: http-longlived-server
spec:
  selector:
    matchLabels:
      app: http-longlived-server
  template:
    metadata:
      labels:
        app: http-longlived-server
    spec:
      containers:
      - name: long-echo
        image: projectalexo/long-echo
        imagePullPolicy: Always
        env:
        - name: NC_MAX_IDLE
          value: "20"

EOF
```

This example deployment is primitive; each pod will accept
one connection at a time, and will respond to the client
when it receives client data. If the connection closes, the pod
can accept another connection.

The connection can be closed from the client-side with Ctrl+c,
or by letting the connection idle for 20s (or however long
`NC_MAX_IDLE` is).

## Apply a Service YAML

Now to expose a new Loadbalancer IP for the router:

```sh
kubectl apply -f -<<EOF
apiVersion: v1
kind: Service
metadata:
  name: http-longlived-server
spec:
  selector:
    app: http-longlived-server
  ports:
    - port: 80
      targetPort: 9000
      name: default
  type: LoadBalancer
EOF
```

And checking the IP that was allocated with `kubectl get svc -o wide`:

```
NAME                    TYPE           CLUSTER-IP       EXTERNAL-IP     PORT(S)        AGE     SELECTOR
http-longlived-server   LoadBalancer   10.102.84.236    192.210.123.1   80:31248/TCP   10s     app=http-longlived-server
http-server             LoadBalancer   10.105.234.165   192.210.123.0   80:32351/TCP   6h1m    app=http-server
kubernetes              ClusterIP      10.96.0.1        <none>          443/TCP        6h27m   <none>
```

## Test Connectivity

Now, let's SSH into the router instance, and from there open a new
connection to the new LoadBalancer IP. Note that since `curl` attempts
to close the connection after receiving a response, we will instead
use Netcat, A.K.A. `nc`, which will leave the connection open until
we manually close it.

```sh
service_ip=<your http-longlived-server IP here>
nc $service_ip 80
```

The connection is working if, after typing text and hitting enter,
the server replies. Keep in mind that if no data is sent for longer
than the timeout (default 20s), sending data will cause the connection
to exit immediately. At this point you may open another.

```
# nc $service_ip 80
This is sent from the client!
[http-longlived-server-mf4vz] Server says: 'This is sent from the client!'
```

Our persistent connection is staying open, and a backing pod is
logging the data we sent from the router.

We will continue using this method to verify the connection
is open. If at any point the text we send does not appear in
the pod logs, then we know the connection has broken.
