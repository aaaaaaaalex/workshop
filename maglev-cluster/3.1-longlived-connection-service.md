# Create Deployment Which Maintains Long-Lived Connections

## Apply a DaemonSet YAML

Create a deployment which will accept new connections
and keep them open, until we manually close them:

```sh
kubectl apply -f -<<EOF
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: http-longlived-server
  labels:
    app: http-longlived-server
spec:
  selector:
    matchLabels:
      app: http-longlived-server
  template:
    metadata:
      labels:
        app: http-longlived-server
    spec:
      containers:
      - name: multitool
        image: wbitt/network-multitool
        command: ["sh", "-c", "while true; do echo \$HOSTNAME | nc -vvnl 9000; done "]
EOF
```

Note: "$HOSTNAME" has been escaped in the above snippet,
so as not to be resolved by your local machine's shell.
We intend for the pod to resolve the env-var, so that
we are told which pod is responding to our requests.

This example deployment is primitive; each pod will accept
one connection at a time, and will respond to the initiator
with the pod hostname. When the connection closes, the pod
can accept another connection.

## Apply a Service YAML

Now to expose a new Loadbalancer IP for the router:

```sh
kubectl apply -f -<<EOF
apiVersion: v1
kind: Service
metadata:
  name: http-longlived-server
spec:
  selector:
    app: http-longlived-server
  ports:
    - port: 80
      targetPort: 9000
      name: default
  type: LoadBalancer
EOF
```

And checking the IP that was allocated with `kubectl get svc -o wide`:

```
NAME                    TYPE           CLUSTER-IP       EXTERNAL-IP     PORT(S)        AGE     SELECTOR
http-longlived-server   LoadBalancer   10.102.84.236    192.210.123.1   80:31248/TCP   10s     app=http-longlived-server
http-server             LoadBalancer   10.105.234.165   192.210.123.0   80:32351/TCP   6h1m    app=http-server
kubernetes              ClusterIP      10.96.0.1        <none>          443/TCP        6h27m   <none>
```

## Test Connectivity

Now, let's SSH into the router instance, and from there open a new connection
to the new  LoadBalancer IP. Note that since `curl` attempts to close the
connection after receiving a response, we will instead use Netcat, A.K.A. `nc`,
which will leave the connection open until we manually close it.

```
$ nc 192.210.123.1 80
http-longlived-server-5rvf6
```

The backing pod returned it's hostname (pod name) to us and the connection remains open.
In a separate terminal window, on our local machine, let's follow the logs of the backing pods:

```sh
kubectl logs --since=1s -fl app=http-longlived-server
```

And now, back on our router SSH session, let's type some arbitrary
text into the `nc` terminal and hit Enter:

```
$ nc 192.210.123.1 80
http-longlived-server-5rvf6
Hello this is the router!

```

... and back to the logs we're following:

```
Connection received on 172.16.101.178 35058
Hello this is the router!
```

Our persistent connection is staying open, and a backing pod is
logging the data we sent from the router.

We will continue using this method to verify the connection
is open. If at any point, the text we send does not appear in
the pod logs, then we know the connection has broken.
