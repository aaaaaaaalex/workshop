# Create Deployment Which Maintains Long-Lived Connections

## Cleanup old test resources

We can now delete our old daemonset and service, as they are
no longer needed:

```sh
kubectl delete svc http-server
kubectl delete ds http-server
```

## Create a DaemonSet of servers that maintain long-lived TCP connections.

Create a deployment which will accept new connections
and keep them open, until we manually close them, or
until the connection idles long enough to time out (20s).

For this purpose I'm using my own basic incantation.
The source-code is in this directory ("long-echo").

```sh
kubectl apply -f -<<EOF
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: http-longlived-server
  labels:
    app: http-longlived-server
spec:
  selector:
    matchLabels:
      app: http-longlived-server
  template:
    metadata:
      labels:
        app: http-longlived-server
    spec:
      containers:
      - name: long-echo
        image: projectalexo/long-echo
        imagePullPolicy: Always
        env:
        - name: NC_MAX_IDLE
          value: "20"

EOF
```

This example deployment is primitive; each pod will accept
one connection at a time, and will echo back any data received
from the client. If the connection closes, the pod can accept
another connection. If the connection idles for a specified timeout,
the server will cleanup the connection and start listening for new ones.

The connection can be closed from the client-side with Ctrl+c,
or by letting the connection idle for a given timeout - however long
`NC_MAX_IDLE` env var is, in seconds.

## Apply a Service YAML

Now to expose a new Loadbalancer IP for us to use from the router:

```sh
kubectl apply -f -<<EOF
apiVersion: v1
kind: Service
metadata:
  name: http-longlived-server
spec:
  selector:
    app: http-longlived-server
  ports:
    - port: 80
      targetPort: 9000
      name: default
  type: LoadBalancer
EOF
```

And check the IP that was allocated with `kubectl get svc -o wide`:

```
NAME                    TYPE           CLUSTER-IP       EXTERNAL-IP     PORT(S)        AGE     SELECTOR
http-longlived-server   LoadBalancer   10.102.84.236    192.210.123.1   80:31248/TCP   10s     app=http-longlived-server
kubernetes              ClusterIP      10.96.0.1        <none>          443/TCP        6h27m   <none>
```

I'm going to store this service's ip and reference it in later scripts.
Remember to use your own service's IP here if it differs from mine:

```sh
service_ip=192.210.123.1
```

## Test Connectivity

Now, let's SSH into the router instance, and from there open a new
connection to the new LoadBalancer IP. Note that since `curl` attempts
to close the connection after receiving a response, we will instead
use Netcat, A.K.A. `nc`, which will leave the connection open until
we manually close it.

```sh
nc $service_ip 80
```

The connection is working if, after typing text and hitting enter,
the server replies. Keep in mind that if no data is sent for longer
than the timeout (set to 20s in the above manifest), sending data
will cause the connection to exit immediately. At this point you may
open another connection.

```
# nc $service_ip 80
This is sent from the client!
[http-longlived-server-mf4vz] Server says: 'This is sent from the client!'
```

Our persistent connection is staying open, and a backing pod is
echo'ing the data we send it. So long as no nexthops churn in the router's
ECMP route, this connection will go on working. However, if at any point,
the connection stops responding, or if routing gets shuffled, our connection
is at-risk of being forwarded via a node which does not recognize it, and getting
dropped.

We will continue using this daemonset & service to verify our connectivity works.
If at any point, we stop receiving echo's from the backend (before the idle
timeout has elapsed), then we can conclude the connection has broken.
